##' Calculate lower and upper the bounds for pairwise correlations
##'
##' The function calculates upper and lower bounds for pairwise
##' correlations given a vector of marginal probabilities as detailed
##' in Emrich and Piedmonte (1991).
##' @title Calculate lower and upper the bounds for pairwise
##'   correlations
##' @param R Correlation matrix
##' @param p Vector of marginal frequencies
##' @return A list with three entries:
##'  \describe{
##' \item{\emph{L}}{Matrix of lower bounds}
##' \item{\emph{U}}{Matrix of upper bounds}
##' \item{\emph{Z}}{Matrix that indicates whether specified
##' correlations in R are bigger or smaller than the calculated
##' bounds}
##' }
##' @references Emrich, L.J., Piedmonte, M.R.: A method for generating
##'   highdimensional multivariate binary variates. The American
##'   Statistician 45(4), 302 (1991).
##' @author Jochen Kruppa, Klaus Jung
##' @export
##' @examples
##' ### A simple example
##' R <- diag(4)
##' p <- c(0.1, 0.2, 0.4, 0.5)
##' 
##' rho.bounds(R, p)
rho.bounds = function(R, p) {
  n = dim(R)[1]
  m = dim(R)[2]
  if (n!=m || R!=t(R)) {
    cat("Error: Correlation matrix has to be symmetric!")
    break
	}
  q = 1 - p
  U = matrix(NA, n, n)
  L = matrix(NA, n, n)
  Z = matrix("OK", n, n)
  for (i in 1:n) {
    for (j in 1:n) {
      L[i,j] = max(c(-sqrt(p[i]*p[j]/q[i]*q[j]), -sqrt(q[i]*q[j]/p[i]*p[j])))
      U[i,j] = max(c(sqrt(p[i]*q[j]/p[j]*q[i]), sqrt(p[j]*q[i]/p[i]*q[j])))
      if (R[i,j]>U[i,j]) Z[i,j] = "big"
      if (R[i,j]<L[i,j]) Z[i,j] = "small"
    }
  }
  diag(U) = NA
  diag(L) = NA
  diag(Z) = NA
  out = list(L=L, U=U, Z=Z)
}

##' Generation of the start matrix with n rows and specified marginal
##' probabilities p.
##'
##' The start matrix needs to be setup for further use in the genetic
##' algorithm implemented in the function \code{\link{iter.matrix}}. For
##' high-dimensional cases or if the marginal probabilities have
##' multiple decimal places, the number n of rows should be large (up
##' to multiple thousand).
##' @title Setup of the start matrix
##' @param p Marginal probabilities of the start matrix
##' @param n Number of rows to be generated
##' @return A (n x p)-Matrix with with entries 0 and 1 according to
##'   the specified marginal probabilities p.
##' @author Jochen Kruppa, Klaus Jung
##' @export
##' @examples
##' X0 <- start.matrix(n = 100, p = c(0.5, 0.6))
start.matrix = function(p, n) {
  d = length(p)
  X0 = matrix(NA, n, d)
  for (j in 1:d) {
    p0 = n*(1-p[j])
    p1 = n*p[j]
    vec = c(rep(0, p0), rep(1, p1))
    if (length(vec)<n) vec = c(vec, 1)
    X0[,j] = vec
  }
  return(X0)
}

##' Starts the genetic algorithm based on a start matrix with
##' specified marginal probabilities.
##' 
##' In each step, the genetic algorithm swaps two randomly selected
##' entries in each column of X0. Thus it can be guaranteed that the
##' marginal probabilities do not change. If the covariance matrix of
##' X0(t) is gets to V in step t X0(t) replaces X0(t-1).
##' @title Genetic algorithm for generating correlated binary data
##' @param X0 Start matrix with specified marginal probabilities. Can
##'   be generated by \code{\link{start.matrix}}.
##' @param V Desired covariance matrix the data should have after
##'   running the genetic algorithm
##' @param tloc Maximum number of iterations after which the genetic
##'   algorithm stops
##' @param e.break Minimum error between the covariance of the
##'   iterated data matrix and V.
##' @param plt Boolean parameter that indicates whether to plot
##'   e.break versus the iteration step
##' @param perc Boolean parameter that indicates whether to print the
##'   percentage of iteration steps relativ to Tloc have been carried
##'   out
##' @return A list with four entries:
##'  \describe{
##' \item{\emph{X1}}{Final data with specified marginal probabilities and a covariance as close as possible to V} 
##' \item{\emph{t}}{Number of performed iteration steps (t <= Tloc)}
##' \item{\emph{V1}}{Covariance matrix of X1}
##' \item{\emph{e}}{Final RSME error between desired and achieved covariance matrix }
##' }
##' @author Jochen Kruppa, Klaus Jung
##' @export
##' @examples
##' ### A simple example
##' X0 = start.matrix(n = 100, p = c(0.5, 0.6))
##' X = iter.matrix(X0, V = diag(2))
iter.matrix = function(X0, V, tloc=1000, e.break=.0001, plt=TRUE, perc=TRUE) {
  n = dim(X0)[1]
  d = dim(X0)[2]
  V0 = cor(X0)
  V0[which(is.na(V0))] = 0
  e0 = sqrt(sum((V - V0)^2) / (n * d))
  e = e0
  maxe = e0
  for (t in 1:tloc) { ### START ITERATION
    if (t%%(tloc/10)==0 & perc==TRUE) print(paste(100 * t/tloc, "%"))
    V0 = cor(X0)
    V0[which(is.na(V0))] = 0
    e0 = sqrt(sum((V - V0)^2) / (n * d))
    X1 = X0
    for (j in 1:d) {
      k = sample(1:n, 2, replace=FALSE)
      a = X0[k[1],j]
      b = X0[k[2],j]
      X1[k[1],j] = b
      X1[k[2],j] = a
    }
    V1 = cor(X1)
    V1[which(is.na(V1))] = 0
    e1 = sqrt(sum((V - V1)^2) / (n * d))
    if (e1 <= e0) {
      X0 = X1
      e = c(e, e1)
    }
    else {
      e = c(e, e0)
      V1 = V0
    }
    if (t%%(tloc/10)==0 & plt==TRUE) {
      plot(1:(t+1), e, type="l", cex.lab=1.5, cex.axis=1.5, xlab="Number of translocations", ylab="Root mean square error", xlim=c(0, tloc), ylim=c(0, maxe), lwd=2)
      grid()
    }
    if (e[t]<e.break & plt==TRUE) {
      plot(1:(t+1), e, type="l", cex.lab=1.5, cex.axis=1.5, xlab="Number of translocations", ylab="Root mean square error", xlim=c(0, tloc), ylim=c(0, maxe), lwd=2)
      grid()
      break
    }
    if (e[t]<e.break) break
  } ### END ITERATION
  out = list(X1=X1, t=t, V1=V1, e=e)
}


##' Calculation of proabilities for binary sequences based on the
##' final matrix generated by the genetic algorithm
##'
##' Observation of binary correlated binary data can be expressed as
##' binary sequences. In the case of two binary variables possible
##' observations are (0,0), (0,1), (1,0) and (1,1). In general, 2^m
##' binary sequences are possible, where m is the number of binary
##' variables. Based on the representative matrix generated by the
##' genetic algorithm the probability for each binary sequence is
##' determined.
##' @title Calculation of probabilities for binary sequences
##' @param X1 Representative matrix generated by the genetic algorithm
##'   with \code{\link{iter.matrix}}
##' @return A vector of probabilities for the binary sequences
##' @author Jochen Kruppa, Klaus Jung
##' @export
##' @examples
##' ### A simple example
##' X0 = start.matrix(n = 100, p = c(0.5, 0.6))
##' X = iter.matrix(X0, V = diag(2))
##' sequence.probs(X)
sequence.probs = function(X1) {
  n = dim(X1)[1]
  binseq = rep("free", n)
  for (i in 1:n) {
    binseq_i = "F"
    for (j in 1:d) {
      binseq_i = paste(binseq_i, as.character(X1[i,j]), sep="")
    }
    binseq[i] = binseq_i
  }
  tabbinseq = table(binseq) / n
  return(tabbinseq)
}


##' A diagnostic plot that compares the entries of two covariance
##' matrices using a color scale.
##'
##' A diagnostic plot that compares the entries of two covariance
##' matrices using a color scale.
##' @title Diagnostic plot for comparison of two covariance matrices
##' @param V0 Specified covariance matrix
##' @param V1 Covariance matrix of the data generated by the genetic
##'   algorithm
##' @param eps Permitted difference between the entries of two
##'   matrices. Must only be specified if col.method="traficlight"
##' @param col.method Method to use for color scaling the difference
##'   between the matrices. If method="traficlight" only two colors
##'   are used, indicating whether the entries deviated at least by a
##'   difference of eps. If method="updown" a discrete gray scale is
##'   used.
##' @param color Value of two color that are used if method="traficlight"
##' @param top Specifies the main title of the plot
##' @return NULL
##' @author Jochen Kruppa, Klaus Jung
##' @export
##' @examples
##' ### A simple example
##' X0 = start.matrix(n = 100, p = c(0.1, 0.2, 0.3))
##' X = iter.matrix(X0, V = diag(3))
##' GA.diagplot(diag(3), X$V1)
GA.diagplot = function(V0, V1, eps=0.05, col.method="traficlight", color=c(0, 8), top="") {
  rotate = function(x) t(apply(x, 2, rev))
  D = V0 - V1
  D = rotate(D)
  d = dim(D)[1]
  if (col.method=="traficlight") {
    COL = matrix(color[1], d, d)
    plot(0:d, 0:d, type="n", axes=FALSE, xlab="", ylab="", main=top)
    for (i in 0:(d-1)) {
      for (j in 0:(d-1)) {
        if (abs(D[i+1,j+1])>eps) COL[i+1,j+1] = color[2]
        rect(i, j, i+1, j+1, col=COL[i+1,j+1], border=0)
      }}
  }
  if (col.method=="updown") {
    COL0 = gray(seq(1, 0, length.out=21))
    COL = matrix(COL0[11], d, d)
    plot(0:d, 0:d, type="n", axes=FALSE, xlab="", ylab="", main=top)
    for (i in 0:(d-1)) {
      for (j in 0:(d-1)) {
        COL[i+1,j+1] = COL0[round(100*D[i+1,j+1]+11)]
        rect(i, j, i+1, j+1, col=COL[i+1,j+1], border=0)
      }}
  }
  for (i in 1:d) text(i-0.5, d-0.5, i)
  for (i in 2:d) text(0.5, d-0.5-(i-1), i)
  box()
}

