##' Calculate lower and upper the bounds for pairwise correlations
##'
##' The function calculates upper and lower bounds for pairwise
##' correlations given a vector of marginal probabilities as detailed
##' in Emrich and Piedmonte (1991).
##' @title Calculate lower and upper the bounds for pairwise
##'   correlations
##' @param p Vector of marginal frequencies
##' @param R Correlation matrix
##' @return A list with three entries:
##'  \describe{
##' \item{\emph{L}}{Matrix of lower bounds}
##' \item{\emph{U}}{Matrix of upper bounds}
##' \item{\emph{Z}}{Matrix that indicates whether specified
##' correlations in R are bigger or smaller than the calculated
##' bounds}
##' }
##' @references Emrich, L.J., Piedmonte, M.R.: A method for generating
##'   highdimensional multivariate binary variates. The American
##'   Statistician 45(4), 302 (1991).
##' @author Jochen Kruppa, Klaus Jung
##' @export
##' @examples
##' ### A simple example
##' R <- diag(4)
##' p <- c(0.1, 0.2, 0.4, 0.5)
##' 
##' rho.bounds(p, R)
rho.bounds <- function(p, R=diag(length(p))) {
  n = dim(R)[1]
  m = dim(R)[2]
  if (n!=m || R!=t(R)) {
    cat("Error: Correlation matrix has to be symmetric!")
    break
  }
  q = 1 - p
  U = matrix(NA, n, n)
  L = matrix(NA, n, n)
  Z = matrix("OK", n, n)
  for (i in 1:n) {
    for (j in 1:n) {
      L[i,j] = max(c(-sqrt(p[i]*p[j]/q[i]*q[j]), -sqrt(q[i]*q[j]/p[i]*p[j])))
      U[i,j] = min(c(sqrt(p[i]*q[j]/p[j]*q[i]), sqrt(p[j]*q[i]/p[i]*q[j])))
      if (R[i,j]>U[i,j]) Z[i,j] = "big"
      if (R[i,j]<L[i,j]) Z[i,j] = "small"
    }
  }
  diag(U) = NA
  diag(L) = NA
  diag(Z) = NA
  out = list(L=L, U=U, Z=Z)
}

##' Generation of the start matrix with n rows and specified marginal
##' probabilities p.
##'
##' The start matrix needs to be setup for further use in the genetic
##' algorithm implemented in the function \code{\link{iter.matrix}}. For
##' high-dimensional cases or if the marginal probabilities have
##' multiple decimal places, the number n of rows should be large (up
##' to multiple thousand).
##' @title Setup of the start matrix
##' @param p Marginal probabilities of the start matrix
##' @param k Number of rows to be generated
##' @return A (n x p)-Matrix with with entries 0 and 1 according to
##'   the specified marginal probabilities p.
##' @author Jochen Kruppa, Klaus Jung
##' @export
##' @examples
##' X0 <- start.matrix(p = c(0.5, 0.6), k = 100)
start.matrix <- function(p, k) {
  m = length(p)
  X0 = matrix(NA, k, m)
  for (j in 1:m) {
    p0 = k*(1-p[j])
    p1 = k*p[j]
    vec = c(rep(0, p0), rep(1, p1))
    if (length(vec)<k) vec = c(vec, 1)
    X0[,j] = vec
  }
  return(X0)
}

##' Starts the genetic algorithm based on a start matrix with
##' specified marginal probabilities.
##' 
##' In each step, the genetic algorithm swaps two randomly selected
##' entries in each column of X0. Thus it can be guaranteed that the
##' marginal probabilities do not change. If the correlation matrix of
##' X0(t) is gets to V in step t X0(t) replaces X0(t-1).
##' @title Genetic algorithm for generating correlated binary data
##' @param X0 Start matrix with specified marginal probabilities. Can
##'   be generated by \code{\link{start.matrix}}.
##' @param R Desired correlation matrix the data should have after
##'   running the genetic algorithm
##' @param T Maximum number of iterations after which the genetic
##'   algorithm stops
##' @param e.min Minimum error between the correlation of the
##'   iterated data matrix and V.
##' @param plt Boolean parameter that indicates whether to plot
##'   e.break versus the iteration step
##' @param perc Boolean parameter that indicates whether to print the
##'   percentage of iteration steps relativ to Tloc have been carried
##'   out
##' @return A list with four entries:
##'  \describe{
##' \item{\emph{Xt}}{Final data with specified marginal probabilities and a correlation as close as possible to V} 
##' \item{\emph{t}}{Number of performed iteration steps (t <= T)}
##' \item{\emph{Rt}}{Correlation matrix of Xt}
##' \item{\emph{RMSE}}{Final RSME error between desired and achieved correlation matrix }
##' }
##' @author Jochen Kruppa, Klaus Jung
##' @export
##' @examples
##' ### A simple example
##' X0 <- start.matrix(p = c(0.5, 0.6), k = 100)
##' X <- iter.matrix(X0, R = diag(2))
iter.matrix <- function(X0, R, T=1000, e.min=.0001, plt=TRUE, perc=TRUE) {
  n = dim(X0)[1]
  m = dim(X0)[2]
  R0 = cor(X0)
  R0[which(is.na(R0))] = 0
  e0 = sqrt(sum((R - R0)^2) / (n * n))
  et = e0
  maxe = e0
  for (t in 1:T) { ### START ITERATION
    if (t%%(T/10)==0 & perc==TRUE) print(paste(100 * t/T, "%"))
    R0 = cor(X0)
    R0[which(is.na(R0))] = 0
    e0 = sqrt(sum((R - R0)^2) / (n * n))
    Xt = X0
    for (j in 1:m) {
      k = sample(1:n, 2, replace=FALSE)
      a = X0[k[1],j]
      b = X0[k[2],j]
      Xt[k[1],j] = b
      Xt[k[2],j] = a
    }
    Rt = cor(Xt)
    Rt[which(is.na(Rt))] = 0
    e1 = sqrt(sum((R - Rt)^2) / (n * n))
    if (e1 <= e0) {
      X0 = Xt
      et = c(et, e1)
    }
    else {
      et = c(et, e0)
      Rt = R0
    }
    if (t%%(T/10)==0 & plt==TRUE) {
      plot(1:(t+1), et, type="l", cex.lab=1.5, cex.axis=1.5, xlab="Number of translocations", ylab="Root-mean-square error", xlim=c(0, T), ylim=c(0, maxe), lwd=2)
      grid()
    }
    if (et[t]<e.min & plt==TRUE) {
      plot(1:(t+1), et, type="l", cex.lab=1.5, cex.axis=1.5, xlab="Number of translocations", ylab="RMSE", xlim=c(0, T), ylim=c(0, maxe), lwd=2)
      grid()
      break
    }
    if (et[t]<e.min) break
  } ### END ITERATION
  RMSE = rep(NA, T)
  RMSE[1:t] = et[1:t]
  out = list(Xt=Xt, t=t, Rt=Rt, RMSE=RMSE)
}

##' Calculation of proabilities for binary sequences based on the
##' final matrix generated by the genetic algorithm
##'
##' Observation of binary correlated binary data can be expressed as
##' binary sequences. In the case of two binary variables possible
##' observations are (0,0), (0,1), (1,0) and (1,1). In general, 2^m
##' binary sequences are possible, where m is the number of binary
##' variables. Based on the representative matrix generated by the
##' genetic algorithm the probability for each binary sequence is
##' determined.
##' @title Calculation of probabilities for binary sequences
##' @param X1 Representative matrix generated by the genetic algorithm
##'   with \code{\link{iter.matrix}}
##' @return A vector of probabilities for the binary sequences
##' @author Jochen Kruppa, Klaus Jung
##' @export
##' @examples
##' ### A simple example
##' X0 <- start.matrix(p = c(0.5, 0.6), k = 100)
##' X <- iter.matrix(X0, R = diag(2))
##' sequence.probs(Xt = X)
sequence.probs <- function(Xt) {
  n = dim(Xt)[1]
  binseq = rep("free", n)
  for (i in 1:n) {
    binseq_i = "F"
    for (j in 1:m) {
      binseq_i = paste(binseq_i, as.character(Xt[i,j]), sep="")
    }
    binseq[i] = binseq_i
  }
  tabbinseq = table(binseq) / n
  return(tabbinseq)
}


##' A diagnostic plot that compares the entries of two correlation
##' matrices using a color scale.
##'
##' A diagnostic plot that compares the entries of two correlation
##' matrices using a color scale.
##' @title Diagnostic plot for comparison of two correlation matrices
##' @param R Specified correlation matrix
##' @param Rt Correlation matrix of the data generated by the genetic
##'   algorithm
##' @param eps Permitted difference between the entries of two
##'   matrices. Must only be specified if col.method="traficlight"
##' @param col.method Method to use for color scaling the difference
##'   between the matrices. If method="traficlight" only two colors
##'   are used, indicating whether the entries deviated at least by a
##'   difference of eps. If method="updown" a discrete gray scale is
##'   used.
##' @param color Value of two color that are used if method="traficlight"
##' @param top Specifies the main title of the plot
##' @return NULL
##' @author Jochen Kruppa, Klaus Jung
##' @export
##' @examples
##' ### A simple example
##' X0 <- start.matrix(p = c(0.1, 0.2, 0.3), k = 100)
##' X <- iter.matrix(X0, R = diag(3))
##' GA.diagplot(diag(3), Rt = X$Rt)
GA.diagplot <- function(R, Rt, eps=0.05, col.method="traficlight", color=c(0, 8), top="") {
  rotate = function(x) t(apply(x, 2, rev))
  D = R - Rt
  D = rotate(D)
  m = dim(D)[1]
  if (col.method=="traficlight") {
    COL = matrix(color[1], m, m)
    plot(0:m, 0:m, type="n", axes=FALSE, xlab="", ylab="", main=top)
    for (i in 0:(m-1)) {
      for (j in 0:(m-1)) {
        if (abs(D[i+1,j+1])>eps) COL[i+1,j+1] = color[2]
        rect(i, j, i+1, j+1, col=COL[i+1,j+1], border=0)
      }}
  }
  if (col.method=="updown") {
    COL0 = gray(seq(1, 0, length.out=21))
    COL = matrix(COL0[11], m, m)
    plot(0:m, 0:m, type="n", axes=FALSE, xlab="", ylab="", main=top)
    for (i in 0:(m-1)) {
      for (j in 0:(m-1)) {
        COL[i+1,j+1] = COL0[round(100*D[i+1,j+1]+11)]
        rect(i, j, i+1, j+1, col=COL[i+1,j+1], border=0)
      }}
  }
  for (i in 1:m) text(i-0.5, m-0.5, i)
  for (i in 2:m) text(0.5, m-0.5-(i-1), i)
  box()
}
